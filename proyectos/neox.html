<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Neon Space Defender</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020207;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #score-board {
            color: #00ffff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
        }

        #health-bar-container {
            width: 300px;
            height: 20px;
            border: 2px solid #ff0055;
            border-radius: 10px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #ff0055;
            box-shadow: 0 0 15px #ff0055;
            transition: width 0.2s;
        }

        #start-screen,
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border: 1px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
            display: flex;
            /* Flex para centrar */
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        h1 {
            margin: 0;
            font-size: 40px;
            text-transform: uppercase;
            letter-spacing: 5px;
            color: #fff;
            text-shadow: 0 0 20px #00ffff;
        }

        p {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 20px;
        }

        button {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 40px;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 10px #00ffff;
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <!-- UI DEL JUEGO -->
    <div id="ui-layer">
        <div id="score-board">SCORE: 0</div>
        <div id="health-bar-container">
            <div id="health-bar"></div>
        </div>
    </div>

    <!-- PANTALLA INICIO -->
    <div id="start-screen">
        <h1>Neon Defender</h1>
        <p>MOUSE para Mover | CLICK para Disparar</p>
        <button onclick="startGame()">Iniciar Misión</button>
    </div>

    <!-- PANTALLA GAME OVER -->
    <div id="game-over-screen" class="hidden">
        <h1 style="color: #ff0055; text-shadow: 0 0 20px #ff0055;">SISTEMA CRÍTICO</h1>
        <p>Puntuación Final: <span id="final-score">0</span></p>
        <button onclick="resetGame()">Reiniciar</button>
    </div>

    <!-- Importmap para Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- VARIABLES GLOBALES DEL JUEGO ---
        let scene, camera, renderer, composer;
        let player;
        let bullets = [];
        let enemies = [];
        let particles = []; // Explosiones
        let gameActive = false;
        let score = 0;
        let health = 100;
        let frameCount = 0;
        let difficultyMultiplier = 1;

        // Mouse
        const mouse = new THREE.Vector2();
        const targetPos = new THREE.Vector3();
        let isShooting = false;

        // Settings visuales
        const PLAYER_SPEED = 0.15;
        const COLORS = {
            player: 0x00ffff,
            enemy: 0xff0055,
            bullet: 0xffff00,
            grid: 0x220033
        };

        init();
        animate();

        function init() {
            // 1. ESCENA
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.035);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 10);
            camera.lookAt(0, 0, -10);

            // 2. RENDERER & BLOOM (Estilo Synthwave)
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 2.0; // ¡Mucho brillo!
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 3. ENTORNO
            createEnvironment();

            // 4. JUGADOR
            createPlayer();

            // Eventos
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', () => isShooting = true);
            document.addEventListener('mouseup', () => isShooting = false);

            // Exponer funciones globales para los botones HTML
            window.startGame = () => {
                document.getElementById('start-screen').classList.add('hidden');
                gameActive = true;
                score = 0;
                health = 100;
                difficultyMultiplier = 1;
                updateUI();
            };

            window.resetGame = () => {
                document.getElementById('game-over-screen').classList.add('hidden');

                // Limpiar enemigos y balas
                enemies.forEach(e => scene.remove(e.mesh));
                bullets.forEach(b => scene.remove(b.mesh));
                enemies = [];
                bullets = [];

                player.position.set(0, 0, 0);
                gameActive = true;
                score = 0;
                health = 100;
                difficultyMultiplier = 1;
                updateUI();
            };
        }

        function createEnvironment() {
            // Piso de Rejilla "Infinita"
            const gridHelper = new THREE.GridHelper(200, 50, 0xff00ff, 0x220044);
            gridHelper.position.y = -2;
            scene.add(gridHelper);

            // Estrellas de fondo
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1000;
            const starPos = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount * 3; i++) {
                starPos[i] = (Math.random() - 0.5) * 200;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
            const stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);
        }

        function createPlayer() {
            // Nave simple construida con primitivas
            const group = new THREE.Group();

            // Cuerpo
            const geometry = new THREE.ConeGeometry(0.8, 2, 4);
            geometry.rotateX(Math.PI / 2); // Apuntar hacia adelante
            geometry.rotateY(Math.PI / 4); // Rotar para que la base plana esté abajo
            const material = new THREE.MeshBasicMaterial({ color: COLORS.player });
            const body = new THREE.Mesh(geometry, material);
            group.add(body);

            // Motores (brillan gracias al Bloom)
            const engineGeo = new THREE.BoxGeometry(0.3, 0.3, 1);
            const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan puro brilla mucho
            const engineL = new THREE.Mesh(engineGeo, engineMat);
            engineL.position.set(-0.6, 0, 0.5);
            const engineR = new THREE.Mesh(engineGeo, engineMat);
            engineR.position.set(0.6, 0, 0.5);
            group.add(engineL);
            group.add(engineR);

            scene.add(group);
            player = group;
        }

        function createEnemy() {
            // Geometría aleatoria para variar
            const type = Math.random();
            let geo, mat;

            if (type < 0.33) geo = new THREE.IcosahedronGeometry(0.8, 0);
            else if (type < 0.66) geo = new THREE.OctahedronGeometry(0.8, 0);
            else geo = new THREE.BoxGeometry(1, 1, 1);

            mat = new THREE.MeshBasicMaterial({
                color: COLORS.enemy,
                wireframe: true // Estilo retro
            });

            const mesh = new THREE.Mesh(geo, mat);

            // Spawnear lejos en el fondo (-Z) y ancho aleatorio (X)
            const xPos = (Math.random() - 0.5) * 30;
            mesh.position.set(xPos, 0, -40);

            scene.add(mesh);

            // Guardamos datos del enemigo
            enemies.push({
                mesh: mesh,
                speed: (0.1 + Math.random() * 0.1) * difficultyMultiplier,
                rotSpeed: { x: Math.random() * 0.1, y: Math.random() * 0.1 }
            });
        }

        function shoot() {
            const geometry = new THREE.CapsuleGeometry(0.1, 1, 4, 8);
            geometry.rotateX(Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ color: COLORS.bullet });
            const mesh = new THREE.Mesh(geometry, material);

            mesh.position.copy(player.position);
            mesh.position.z -= 1; // Salir desde la punta

            scene.add(mesh);
            bullets.push({ mesh: mesh, speed: 1.0 });

            // Efecto de retroceso visual
            player.position.z += 0.2;
        }

        function createExplosion(position, color) {
            const particleCount = 10;
            const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const mat = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < particleCount; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(position);

                // Velocidad explosiva aleatoria
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(0.2 + Math.random() * 0.3);

                scene.add(mesh);
                particles.push({ mesh: mesh, velocity: vel, life: 1.0 });
            }
        }

        function updateUI() {
            document.getElementById('score-board').innerText = `SCORE: ${score}`;
            document.getElementById('health-bar').style.width = `${Math.max(0, health)}%`;
        }

        function gameOver() {
            gameActive = false;
            createExplosion(player.position, COLORS.player);
            // Ocultar jugador
            player.position.set(0, -100, 0);

            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = score;
        }

        // --- BUCLE PRINCIPAL ---
        function animate() {
            requestAnimationFrame(animate);

            if (!gameActive) {
                // Rotar la escena suavemente si está en menú
                camera.position.x += (Math.sin(Date.now() * 0.001) * 5 - camera.position.x) * 0.01;
                camera.lookAt(0, 0, -10);
                composer.render();
                return;
            }

            frameCount++;
            difficultyMultiplier = 1 + (score / 1000); // Se pone más difícil

            // 1. MOVER JUGADOR
            // Lerp para movimiento suave hacia el mouse
            player.position.x += (targetPos.x - player.position.x) * PLAYER_SPEED;
            player.position.z += (targetPos.z - player.position.z) * PLAYER_SPEED;

            // Inclinar nave al moverse
            player.rotation.z = (player.position.x - targetPos.x) * 0.5;
            // Limitar área de juego
            player.position.x = Math.max(-15, Math.min(15, player.position.x));
            player.position.z = Math.max(-5, Math.min(5, player.position.z));

            // 2. DISPARAR
            if (isShooting && frameCount % 8 === 0) { // Cadencia de disparo
                shoot();
            }

            // 3. GENERAR ENEMIGOS
            // Spawn rate aumenta con la dificultad
            if (frameCount % Math.max(20, Math.floor(60 / difficultyMultiplier)) === 0) {
                createEnemy();
            }

            // 4. ACTUALIZAR BALAS
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.z -= b.speed;

                // Eliminar si sale de pantalla
                if (b.mesh.position.z < -60) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }

            // 5. ACTUALIZAR ENEMIGOS Y COLISIONES
            const playerBox = new THREE.Box3().setFromObject(player);

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.mesh.position.z += e.speed;

                // Rotar enemigo
                e.mesh.rotation.x += e.rotSpeed.x;
                e.mesh.rotation.y += e.rotSpeed.y;

                // Colisión con Jugador
                const enemyBox = new THREE.Box3().setFromObject(e.mesh);
                if (playerBox.intersectsBox(enemyBox)) {
                    health -= 20;
                    updateUI();
                    createExplosion(e.mesh.position, COLORS.enemy);
                    scene.remove(e.mesh);
                    enemies.splice(i, 1);

                    if (health <= 0) gameOver();
                    continue;
                }

                // Colisión con Balas
                let hit = false;
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    const bulletBox = new THREE.Box3().setFromObject(b.mesh);

                    if (enemyBox.intersectsBox(bulletBox)) {
                        // Impacto!
                        createExplosion(e.mesh.position, COLORS.enemy);
                        score += 50;
                        updateUI();

                        scene.remove(e.mesh);
                        enemies.splice(i, 1);
                        scene.remove(b.mesh);
                        bullets.splice(j, 1);
                        hit = true;
                        break;
                    }
                }
                if (hit) continue;

                // Eliminar si pasa al jugador
                if (e.mesh.position.z > 10) {
                    scene.remove(e.mesh);
                    enemies.splice(i, 1);
                    health -= 5; // Castigo por dejar pasar enemigos
                    updateUI();
                    if (health <= 0) gameOver();
                }
            }

            // 6. ACTUALIZAR PARTÍCULAS
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.velocity);
                p.life -= 0.03;
                p.mesh.scale.setScalar(p.life); // Se hacen pequeñas

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            composer.render();
        }

        // --- EVENTOS ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Convertir coordenadas 2D de pantalla a coordenadas 3D de mundo
            // Simplemente mapeamos X e Y a un rango razonable
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Mapeamos a unidades de Three.js (Aproximación para vista isométrica falsa)
            targetPos.x = x * 15;
            targetPos.z = -y * 5; // Invertido para que arriba sea "adentro"
        }

    </script>
</body>

</html>
